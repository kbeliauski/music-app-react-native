{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar performanceNow = require('fbjs/lib/performanceNow');\n\nvar warning = require('fbjs/lib/warning');\n\nvar Info = function Info() {\n  _classCallCheck(this, Info);\n\n  this.any_blank_count = 0;\n  this.any_blank_ms = 0;\n  this.any_blank_speed_sum = 0;\n  this.mostly_blank_count = 0;\n  this.mostly_blank_ms = 0;\n  this.pixels_blank = 0;\n  this.pixels_sampled = 0;\n  this.pixels_scrolled = 0;\n  this.total_time_spent = 0;\n  this.sample_count = 0;\n};\n\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\n\nvar _sampleRate = DEBUG ? 1 : null;\n\nvar FillRateHelper = function () {\n  function FillRateHelper(getFrameMetrics) {\n    _classCallCheck(this, FillRateHelper);\n\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n\n    this._resetData();\n  }\n\n  _createClass(FillRateHelper, [{\n    key: \"activate\",\n    value: function activate() {\n      if (this._enabled && this._samplesStartTime == null) {\n        DEBUG && console.debug('FillRateHelper: activate');\n        this._samplesStartTime = performanceNow();\n      }\n    }\n  }, {\n    key: \"deactivateAndFlush\",\n    value: function deactivateAndFlush() {\n      if (!this._enabled) {\n        return;\n      }\n\n      var start = this._samplesStartTime;\n\n      if (start == null) {\n        DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n        return;\n      }\n\n      if (this._info.sample_count < _minSampleCount) {\n        this._resetData();\n\n        return;\n      }\n\n      var total_time_spent = performanceNow() - start;\n\n      var info = _objectSpread(_objectSpread({}, this._info), {}, {\n        total_time_spent: total_time_spent\n      });\n\n      if (DEBUG) {\n        var derived = {\n          avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n          avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n          avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n          any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n          any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n          mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n          mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n        };\n\n        for (var key in derived) {\n          derived[key] = Math.round(1000 * derived[key]) / 1000;\n        }\n\n        console.debug('FillRateHelper deactivateAndFlush: ', {\n          derived: derived,\n          info: info\n        });\n      }\n\n      _listeners.forEach(function (listener) {\n        return listener(info);\n      });\n\n      this._resetData();\n    }\n  }, {\n    key: \"computeBlankness\",\n    value: function computeBlankness(props, state, scrollMetrics) {\n      if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n        return 0;\n      }\n\n      var dOffset = scrollMetrics.dOffset,\n          offset = scrollMetrics.offset,\n          velocity = scrollMetrics.velocity,\n          visibleLength = scrollMetrics.visibleLength;\n      this._info.sample_count++;\n      this._info.pixels_sampled += Math.round(visibleLength);\n      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n      var scrollSpeed = Math.round(Math.abs(velocity) * 1000);\n      var now = performanceNow();\n\n      if (this._anyBlankStartTime != null) {\n        this._info.any_blank_ms += now - this._anyBlankStartTime;\n      }\n\n      this._anyBlankStartTime = null;\n\n      if (this._mostlyBlankStartTime != null) {\n        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n      }\n\n      this._mostlyBlankStartTime = null;\n      var blankTop = 0;\n      var first = state.first;\n\n      var firstFrame = this._getFrameMetrics(first);\n\n      while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n        firstFrame = this._getFrameMetrics(first);\n        first++;\n      }\n\n      if (firstFrame && first > 0) {\n        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n      }\n\n      var blankBottom = 0;\n      var last = state.last;\n\n      var lastFrame = this._getFrameMetrics(last);\n\n      while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n        lastFrame = this._getFrameMetrics(last);\n        last--;\n      }\n\n      if (lastFrame && last < props.getItemCount(props.data) - 1) {\n        var bottomEdge = lastFrame.offset + lastFrame.length;\n        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n      }\n\n      var pixels_blank = Math.round(blankTop + blankBottom);\n      var blankness = pixels_blank / visibleLength;\n\n      if (blankness > 0) {\n        this._anyBlankStartTime = now;\n        this._info.any_blank_speed_sum += scrollSpeed;\n        this._info.any_blank_count++;\n        this._info.pixels_blank += pixels_blank;\n\n        if (blankness > 0.5) {\n          this._mostlyBlankStartTime = now;\n          this._info.mostly_blank_count++;\n        }\n      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n        this.deactivateAndFlush();\n      }\n\n      return blankness;\n    }\n  }, {\n    key: \"enabled\",\n    value: function enabled() {\n      return this._enabled;\n    }\n  }, {\n    key: \"_resetData\",\n    value: function _resetData() {\n      this._anyBlankStartTime = null;\n      this._info = new Info();\n      this._mostlyBlankStartTime = null;\n      this._samplesStartTime = null;\n    }\n  }], [{\n    key: \"addListener\",\n    value: function addListener(callback) {\n      warning(_sampleRate !== null, 'Call `FillRateHelper.setSampleRate` before `addListener`.');\n\n      _listeners.push(callback);\n\n      return {\n        remove: function remove() {\n          _listeners = _listeners.filter(function (listener) {\n            return callback !== listener;\n          });\n        }\n      };\n    }\n  }, {\n    key: \"setSampleRate\",\n    value: function setSampleRate(sampleRate) {\n      _sampleRate = sampleRate;\n    }\n  }, {\n    key: \"setMinSampleCount\",\n    value: function setMinSampleCount(minSampleCount) {\n      _minSampleCount = minSampleCount;\n    }\n  }]);\n\n  return FillRateHelper;\n}();\n\nmodule.exports = FillRateHelper;","map":{"version":3,"sources":["/Users/kirylbeliauski/Documents/COMP SCI/software engineering/hw4/actual hw/music-rating-app-react-native/node_modules/react-native/Libraries/Lists/FillRateHelper.js"],"names":["performanceNow","require","warning","Info","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","getFrameMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_getFrameMetrics","Math","random","_resetData","console","debug","start","info","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","key","round","forEach","listener","props","state","scrollMetrics","getItemCount","data","dOffset","offset","velocity","visibleLength","abs","scrollSpeed","now","blankTop","first","firstFrame","last","inLayout","min","max","blankBottom","lastFrame","bottomEdge","length","blankness","deactivateAndFlush","callback","push","remove","filter","sampleRate","minSampleCount","module","exports"],"mappings":"AAUA;;;;;;;;;;;;AAEA,IAAMA,cAAc,GAAGC,OAAO,CAAC,yBAAD,CAA9B;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,kBAAD,CAAvB;;IAIME,I;;;OACJC,e,GAA0B,C;OAC1BC,Y,GAAuB,C;OACvBC,mB,GAA8B,C;OAC9BC,kB,GAA6B,C;OAC7BC,e,GAA0B,C;OAC1BC,Y,GAAuB,C;OACvBC,c,GAAyB,C;OACzBC,e,GAA0B,C;OAC1BC,gB,GAA2B,C;OAC3BC,Y,GAAuB,C;;;AAUzB,IAAMC,KAAK,GAAG,KAAd;AAEA,IAAIC,UAAiC,GAAG,EAAxC;AACA,IAAIC,eAAe,GAAG,EAAtB;;AACA,IAAIC,WAAW,GAAGH,KAAK,GAAG,CAAH,GAAO,IAA9B;;IAUMI,c;AA+BJ,0BAAYC,eAAZ,EAA+D;AAAA;;AAAA,SA9B/DC,kBA8B+D,GA9BzC,IA8ByC;AAAA,SA7B/DC,QA6B+D,GA7BpD,KA6BoD;AAAA,SA3B/DC,KA2B+D,GA3BvD,IAAInB,IAAJ,EA2BuD;AAAA,SA1B/DoB,qBA0B+D,GA1BtC,IA0BsC;AAAA,SAzB/DC,iBAyB+D,GAzB1C,IAyB0C;AAC7D,SAAKC,gBAAL,GAAwBN,eAAxB;AACA,SAAKE,QAAL,GAAgB,CAACJ,WAAW,IAAI,CAAhB,IAAqBS,IAAI,CAACC,MAAL,EAArC;;AACA,SAAKC,UAAL;AACD;;;;WAED,oBAAW;AACT,UAAI,KAAKP,QAAL,IAAiB,KAAKG,iBAAL,IAA0B,IAA/C,EAAqD;AACnDV,QAAAA,KAAK,IAAIe,OAAO,CAACC,KAAR,CAAc,0BAAd,CAAT;AACA,aAAKN,iBAAL,GAAyBxB,cAAc,EAAvC;AACD;AACF;;;WAED,8BAAqB;AACnB,UAAI,CAAC,KAAKqB,QAAV,EAAoB;AAClB;AACD;;AACD,UAAMU,KAAK,GAAG,KAAKP,iBAAnB;;AACA,UAAIO,KAAK,IAAI,IAAb,EAAmB;AACjBjB,QAAAA,KAAK,IACHe,OAAO,CAACC,KAAR,CAAc,uDAAd,CADF;AAEA;AACD;;AACD,UAAI,KAAKR,KAAL,CAAWT,YAAX,GAA0BG,eAA9B,EAA+C;AAE7C,aAAKY,UAAL;;AACA;AACD;;AACD,UAAMhB,gBAAgB,GAAGZ,cAAc,KAAK+B,KAA5C;;AACA,UAAMC,IAAS,mCACV,KAAKV,KADK;AAEbV,QAAAA,gBAAgB,EAAhBA;AAFa,QAAf;;AAIA,UAAIE,KAAJ,EAAW;AACT,YAAMmB,OAAO,GAAG;AACdC,UAAAA,aAAa,EAAE,KAAKZ,KAAL,CAAWb,YAAX,GAA0B,KAAKa,KAAL,CAAWZ,cADtC;AAEdyB,UAAAA,SAAS,EAAE,KAAKb,KAAL,CAAWX,eAAX,IAA8BC,gBAAgB,GAAG,IAAjD,CAFG;AAGdwB,UAAAA,wBAAwB,EACtB,KAAKd,KAAL,CAAWhB,mBAAX,GAAiC,KAAKgB,KAAL,CAAWlB,eAJhC;AAKdiC,UAAAA,iBAAiB,EACf,KAAKf,KAAL,CAAWlB,eAAX,IAA8BQ,gBAAgB,GAAG,IAAnB,GAA0B,EAAxD,CANY;AAOd0B,UAAAA,mBAAmB,EAAE,KAAKhB,KAAL,CAAWjB,YAAX,GAA0BO,gBAPjC;AAQd2B,UAAAA,oBAAoB,EAClB,KAAKjB,KAAL,CAAWf,kBAAX,IAAiCK,gBAAgB,GAAG,IAAnB,GAA0B,EAA3D,CATY;AAUd4B,UAAAA,sBAAsB,EAAE,KAAKlB,KAAL,CAAWd,eAAX,GAA6BI;AAVvC,SAAhB;;AAYA,aAAK,IAAM6B,GAAX,IAAkBR,OAAlB,EAA2B;AACzBA,UAAAA,OAAO,CAACQ,GAAD,CAAP,GAAef,IAAI,CAACgB,KAAL,CAAW,OAAOT,OAAO,CAACQ,GAAD,CAAzB,IAAkC,IAAjD;AACD;;AACDZ,QAAAA,OAAO,CAACC,KAAR,CAAc,qCAAd,EAAqD;AAACG,UAAAA,OAAO,EAAPA,OAAD;AAAUD,UAAAA,IAAI,EAAJA;AAAV,SAArD;AACD;;AACDjB,MAAAA,UAAU,CAAC4B,OAAX,CAAmB,UAAAC,QAAQ;AAAA,eAAIA,QAAQ,CAACZ,IAAD,CAAZ;AAAA,OAA3B;;AACA,WAAKJ,UAAL;AACD;;;WAED,0BACEiB,KADF,EAOEC,KAPF,EAYEC,aAZF,EAmBU;AACR,UACE,CAAC,KAAK1B,QAAN,IACAwB,KAAK,CAACG,YAAN,CAAmBH,KAAK,CAACI,IAAzB,MAAmC,CADnC,IAEA,KAAKzB,iBAAL,IAA0B,IAH5B,EAIE;AACA,eAAO,CAAP;AACD;;AACD,UAAO0B,OAAP,GAAmDH,aAAnD,CAAOG,OAAP;AAAA,UAAgBC,MAAhB,GAAmDJ,aAAnD,CAAgBI,MAAhB;AAAA,UAAwBC,QAAxB,GAAmDL,aAAnD,CAAwBK,QAAxB;AAAA,UAAkCC,aAAlC,GAAmDN,aAAnD,CAAkCM,aAAlC;AAIA,WAAK/B,KAAL,CAAWT,YAAX;AACA,WAAKS,KAAL,CAAWZ,cAAX,IAA6BgB,IAAI,CAACgB,KAAL,CAAWW,aAAX,CAA7B;AACA,WAAK/B,KAAL,CAAWX,eAAX,IAA8Be,IAAI,CAACgB,KAAL,CAAWhB,IAAI,CAAC4B,GAAL,CAASJ,OAAT,CAAX,CAA9B;AACA,UAAMK,WAAW,GAAG7B,IAAI,CAACgB,KAAL,CAAWhB,IAAI,CAAC4B,GAAL,CAASF,QAAT,IAAqB,IAAhC,CAApB;AAGA,UAAMI,GAAG,GAAGxD,cAAc,EAA1B;;AACA,UAAI,KAAKoB,kBAAL,IAA2B,IAA/B,EAAqC;AACnC,aAAKE,KAAL,CAAWjB,YAAX,IAA2BmD,GAAG,GAAG,KAAKpC,kBAAtC;AACD;;AACD,WAAKA,kBAAL,GAA0B,IAA1B;;AACA,UAAI,KAAKG,qBAAL,IAA8B,IAAlC,EAAwC;AACtC,aAAKD,KAAL,CAAWd,eAAX,IAA8BgD,GAAG,GAAG,KAAKjC,qBAAzC;AACD;;AACD,WAAKA,qBAAL,GAA6B,IAA7B;AAEA,UAAIkC,QAAQ,GAAG,CAAf;AACA,UAAIC,KAAK,GAAGZ,KAAK,CAACY,KAAlB;;AACA,UAAIC,UAAU,GAAG,KAAKlC,gBAAL,CAAsBiC,KAAtB,CAAjB;;AACA,aAAOA,KAAK,IAAIZ,KAAK,CAACc,IAAf,KAAwB,CAACD,UAAD,IAAe,CAACA,UAAU,CAACE,QAAnD,CAAP,EAAqE;AACnEF,QAAAA,UAAU,GAAG,KAAKlC,gBAAL,CAAsBiC,KAAtB,CAAb;AACAA,QAAAA,KAAK;AACN;;AAGD,UAAIC,UAAU,IAAID,KAAK,GAAG,CAA1B,EAA6B;AAC3BD,QAAAA,QAAQ,GAAG/B,IAAI,CAACoC,GAAL,CACTT,aADS,EAET3B,IAAI,CAACqC,GAAL,CAAS,CAAT,EAAYJ,UAAU,CAACR,MAAX,GAAoBA,MAAhC,CAFS,CAAX;AAID;;AACD,UAAIa,WAAW,GAAG,CAAlB;AACA,UAAIJ,IAAI,GAAGd,KAAK,CAACc,IAAjB;;AACA,UAAIK,SAAS,GAAG,KAAKxC,gBAAL,CAAsBmC,IAAtB,CAAhB;;AACA,aAAOA,IAAI,IAAId,KAAK,CAACY,KAAd,KAAwB,CAACO,SAAD,IAAc,CAACA,SAAS,CAACJ,QAAjD,CAAP,EAAmE;AACjEI,QAAAA,SAAS,GAAG,KAAKxC,gBAAL,CAAsBmC,IAAtB,CAAZ;AACAA,QAAAA,IAAI;AACL;;AAGD,UAAIK,SAAS,IAAIL,IAAI,GAAGf,KAAK,CAACG,YAAN,CAAmBH,KAAK,CAACI,IAAzB,IAAiC,CAAzD,EAA4D;AAC1D,YAAMiB,UAAU,GAAGD,SAAS,CAACd,MAAV,GAAmBc,SAAS,CAACE,MAAhD;AACAH,QAAAA,WAAW,GAAGtC,IAAI,CAACoC,GAAL,CACZT,aADY,EAEZ3B,IAAI,CAACqC,GAAL,CAAS,CAAT,EAAYZ,MAAM,GAAGE,aAAT,GAAyBa,UAArC,CAFY,CAAd;AAID;;AACD,UAAMzD,YAAY,GAAGiB,IAAI,CAACgB,KAAL,CAAWe,QAAQ,GAAGO,WAAtB,CAArB;AACA,UAAMI,SAAS,GAAG3D,YAAY,GAAG4C,aAAjC;;AACA,UAAIe,SAAS,GAAG,CAAhB,EAAmB;AACjB,aAAKhD,kBAAL,GAA0BoC,GAA1B;AACA,aAAKlC,KAAL,CAAWhB,mBAAX,IAAkCiD,WAAlC;AACA,aAAKjC,KAAL,CAAWlB,eAAX;AACA,aAAKkB,KAAL,CAAWb,YAAX,IAA2BA,YAA3B;;AACA,YAAI2D,SAAS,GAAG,GAAhB,EAAqB;AACnB,eAAK7C,qBAAL,GAA6BiC,GAA7B;AACA,eAAKlC,KAAL,CAAWf,kBAAX;AACD;AACF,OATD,MASO,IAAIgD,WAAW,GAAG,IAAd,IAAsB7B,IAAI,CAAC4B,GAAL,CAASJ,OAAT,IAAoB,CAA9C,EAAiD;AACtD,aAAKmB,kBAAL;AACD;;AACD,aAAOD,SAAP;AACD;;;WAED,mBAAmB;AACjB,aAAO,KAAK/C,QAAZ;AACD;;;WAED,sBAAa;AACX,WAAKD,kBAAL,GAA0B,IAA1B;AACA,WAAKE,KAAL,GAAa,IAAInB,IAAJ,EAAb;AACA,WAAKoB,qBAAL,GAA6B,IAA7B;AACA,WAAKC,iBAAL,GAAyB,IAAzB;AACD;;;WAtLD,qBACE8C,QADF,EAE6B;AAC3BpE,MAAAA,OAAO,CACLe,WAAW,KAAK,IADX,EAEL,2DAFK,CAAP;;AAIAF,MAAAA,UAAU,CAACwD,IAAX,CAAgBD,QAAhB;;AACA,aAAO;AACLE,QAAAA,MAAM,EAAE,kBAAM;AACZzD,UAAAA,UAAU,GAAGA,UAAU,CAAC0D,MAAX,CAAkB,UAAA7B,QAAQ;AAAA,mBAAI0B,QAAQ,KAAK1B,QAAjB;AAAA,WAA1B,CAAb;AACD;AAHI,OAAP;AAKD;;;WAED,uBAAqB8B,UAArB,EAAyC;AACvCzD,MAAAA,WAAW,GAAGyD,UAAd;AACD;;;WAED,2BAAyBC,cAAzB,EAAiD;AAC/C3D,MAAAA,eAAe,GAAG2D,cAAlB;AACD;;;;;;AAoKHC,MAAM,CAACC,OAAP,GAAiB3D,cAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nconst performanceNow = require('fbjs/lib/performanceNow');\nconst warning = require('fbjs/lib/warning');\n\nexport type FillRateInfo = Info;\n\nclass Info {\n  any_blank_count: number = 0;\n  any_blank_ms: number = 0;\n  any_blank_speed_sum: number = 0;\n  mostly_blank_count: number = 0;\n  mostly_blank_ms: number = 0;\n  pixels_blank: number = 0;\n  pixels_sampled: number = 0;\n  pixels_scrolled: number = 0;\n  total_time_spent: number = 0;\n  sample_count: number = 0;\n}\n\ntype FrameMetrics = {\n  inLayout?: boolean,\n  length: number,\n  offset: number,\n  ...\n};\n\nconst DEBUG = false;\n\nlet _listeners: Array<(Info) => void> = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  _anyBlankStartTime = (null: ?number);\n  _enabled = false;\n  _getFrameMetrics: (index: number) => ?FrameMetrics;\n  _info = new Info();\n  _mostlyBlankStartTime = (null: ?number);\n  _samplesStartTime = (null: ?number);\n\n  static addListener(\n    callback: FillRateInfo => void,\n  ): {remove: () => void, ...} {\n    warning(\n      _sampleRate !== null,\n      'Call `FillRateHelper.setSampleRate` before `addListener`.',\n    );\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      },\n    };\n  }\n\n  static setSampleRate(sampleRate: number) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount: number) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(getFrameMetrics: (index: number) => ?FrameMetrics) {\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = performanceNow();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG &&\n        console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    const total_time_spent = performanceNow() - start;\n    const info: any = {\n      ...this._info,\n      total_time_spent,\n    };\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank:\n          this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min:\n          this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min:\n          this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent,\n      };\n      for (const key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {derived, info});\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n\n  computeBlankness(\n    props: {\n      data: any,\n      getItemCount: (data: any) => number,\n      initialNumToRender: number,\n      ...\n    },\n    state: {\n      first: number,\n      last: number,\n      ...\n    },\n    scrollMetrics: {\n      dOffset: number,\n      offset: number,\n      velocity: number,\n      visibleLength: number,\n      ...\n    },\n  ): number {\n    if (\n      !this._enabled ||\n      props.getItemCount(props.data) === 0 ||\n      this._samplesStartTime == null\n    ) {\n      return 0;\n    }\n    const {dOffset, offset, velocity, visibleLength} = scrollMetrics;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    const now = performanceNow();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n\n    let blankTop = 0;\n    let first = state.first;\n    let firstFrame = this._getFrameMetrics(first);\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(\n        visibleLength,\n        Math.max(0, firstFrame.offset - offset),\n      );\n    }\n    let blankBottom = 0;\n    let last = state.last;\n    let lastFrame = this._getFrameMetrics(last);\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(\n        visibleLength,\n        Math.max(0, offset + visibleLength - bottomEdge),\n      );\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n\n  enabled(): boolean {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\n\nmodule.exports = FillRateHelper;\n"]},"metadata":{},"sourceType":"script"}